name: Configure CMake Project
description: Configure a CMake project using the specified build type and configuration.

# DISCREPANCY vs Build-CMakeProject in swift/utils/build.ps1:
# This action only configures CMake projects; Build-CMakeProject also builds
# them (via $BuildTargets parameter) and installs them (if $InstallTo is set
# and $BuildTargets is empty).
#
# The following features are present in Build-CMakeProject but missing here:
#   - $Generator parameter (this action hardcodes "Ninja")
#   - $AddAndroidCMakeEnv for setting NDKPATH environment variable
#   - CMAKE_MAKE_PROGRAM define (set to $ninja in the cmdlet)
#   - DWARF debug format support on Windows ($CDebugFormat, $SwiftDebugFormat)
#   - CAS (Content-Addressed Storage) support ($EnableCAS, $CASPath)
#   - PATH setup for Swift runtime when using built/pinned Swift compilers
#   - Extra Swift linker library path for Android SDK (-Xclang-linker -L ...)
#   - VS Developer Shell invocation (Invoke-VsDevShell)
#   - /IGNORE:longsections linker flag for DWARF on Windows
#
# The following features are present here but not in Build-CMakeProject:
#   - CMAKE_Swift_COMPILER_USE_OLD_DRIVER (not set in the cmdlet)
#   - Explicit Android caching exclusion (cmdlet doesn't check OS for caching)
#   - Darwin support (cmdlet only handles Windows and Android)
#
# Other behavioral differences:
#   - Cross-compilation check: This action checks ($OS -ne $BuildOS -or $Arch -ne $BuildArch);
#     the cmdlet checks (($Platform.OS -ne [OS]::Windows) -or ($Platform.Architecture.CMakeName -ne $BuildPlatform.Architecture.CMakeName))
#   - Android C/CXX debug: This action uses "-gsplit-dwarf"; cmdlet uses "-gdwarf"
#   - Pinned compiler paths: This action assumes they're in PATH; cmdlet uses Get-PinnedToolchainToolsDir

inputs:
  project-name:
    description: Name of the CMake project to build.
    required: true
  swift-version:
    description: Built Swift compiler version.
    required: true
  enable-caching:
    description: Enable sccache.
    required: false
    default: false
  debug-info:
    description: Enable debug information in the build.
    required: false
    default: false
  build-os:
    description: Build operating system (e.g., "Windows", "Darwin").
    required: true
  build-arch:
    description: Build architecture (e.g., "x86_64", "arm64").
    required: true
  os:
    description: Operating system to build for (e.g., "Windows", "Android").
    required: true
  arch:
    description: Architecture to build for (e.g., "amd64", "arm64").
    required: true
  src-dir:
    description: Path to the source directory of the CMake project.
    required: true
  bin-dir:
    description: Path to the output directory for the build artifacts.
    required: true
  install-dir:
    description: Path to the installation directory for the built artifacts.
    required: false
    default: ''
  android-api-level:
    description: Android API level to target.
    required: false
    default: ''
  android-clang-version:
    description: Version of the Android Clang toolchain to use.
    required: false
    default: ''
  ndk-path:
    description: Path to the Android NDK.
    required: false
    default: ''
  swift-sdk-path:
    description: Path to the Swift SDK.
    required: false
    default: ''
  msvc-compilers:
    description: List of languages to build with the MSVC compilers (e.g. "C", "CXX", "ASM_MASM").
    required: false
    default: '@()'
  built-compilers:
    description: |
      List of languages to build with the built compilers (e.g. "C", "CXX", "ASM", "Swift").
    required: false
    default: '@()'
  pinned-compilers:
    description: |
      List of languages to build with the pinned compilers (e.g. "C", "CXX", "ASM", "Swift").
    required: false
    default: '@()'
  use-gnu-driver:
    description: Use the GNU driver for building the project.
    required: false
    default: false
  cache-script:
    description: Optional path to a CMake Cache file.
    required: false
    default: ''
  cmake-defines:
    description: |
      Additional CMake definitions to pass to the build system (e.g. "CMAKE_BUILD_TYPE=Release").
    required: false
    default: '@{}'

runs:
  using: 'composite'
  steps:
    - name: Configure ${{ inputs.project-name }}
      shell: pwsh
      run: |
        Remove-Item env:\SDKROOT -ErrorAction SilentlyContinue
        $ExeSuffix = if ($IsWindows) { ".exe" } else { "" }

        $ProjectName = '${{ inputs.project-name }}'
        $SwiftVersion = '${{ inputs.swift-version }}'
        $EnableCaching = ${{ inputs.enable-caching == 'true' && '$True' || '$False' }}
        $DebugInfo = ${{ inputs.debug-info == 'true' && '$True' || '$False' }}
        $BuildOS = '${{ inputs.build-os }}'
        $BuildArch = '${{ inputs.build-arch }}'
        $OS = '${{ inputs.os }}'
        $Arch = '${{ inputs.arch }}'
        $SrcDir = '${{ inputs.src-dir }}'
        $BinDir = '${{ inputs.bin-dir }}'
        $InstallDir = '${{ inputs.install-dir }}'
        $AndroidAPILevel = '${{ inputs.android-api-level }}'
        $AndroidClangVersion = '${{ inputs.android-clang-version }}'
        $NDKPath = '${{ inputs.ndk-path }}'
        $SwiftSDK = '${{ inputs.swift-sdk-path }}'
        $UseMSVCCompilers = ${{ inputs.msvc-compilers }}
        $UseBuiltCompilers = ${{ inputs.built-compilers }}
        $UsePinnedCompilers = ${{ inputs.pinned-compilers }}
        $UseGNUDriver = ${{ inputs.use-gnu-driver == 'true' && '$True' || '$False' }}
        $CacheScript = '${{ inputs.cache-script }}'
        $CMakeDefines = ${{ inputs.cmake-defines }}

        function Add-KeyValueIfNew([hashtable]$Hashtable, [string]$Key, [string]$Value) {
          if (-not $Hashtable.Contains($Key)) {
            $Hashtable.Add($Key, $Value)
          }
        }

        function Add-FlagsDefine([hashtable]$Defines, [string]$Name, [string[]]$Value) {
          if ($Defines.Contains($Name)) {
            $Defines[$name] = @($Defines[$name]) + $Value
          } else {
            $Defines.Add($Name, $Value)
          }
        }

        $CMakeArch = switch ($OS) {
          'Windows' {
            switch ($Arch) {
              'arm64' { 'ARM64' }
              'amd64' { 'AMD64' }
              'x86' { 'i686' }
              default { throw "Unsupported Windows architecture: $Arch" }
            }
          }
          'Android' {
            switch ($Arch) {
              'arm64' { 'aarch64' }
              'x86_64' { 'x86_64' }
              'i686' { 'i686' }
              'armv7' { 'armv7-a' }
              default { throw "Unsupported Android architecture: $Arch" }
            } 
          }
          "Darwin" { $Arch }
          default { throw "Unsupported OS: $OS" }
        }

        $Triple = switch ($OS) {
          'Windows' {
            switch ($Arch) {
              'x86' { "i686-unknown-windows-msvc" }
              'amd64' { "x86_64-unknown-windows-msvc" }
              'arm64' { "aarch64-unknown-windows-msvc" }
              default { throw "Unsupported Windows architecture: $Arch" }
            }
          }
          'Android' {
            switch ($Arch) {
              'i686' { "i686-unknown-linux-android${AndroidAPILevel}" }
              'x86_64' { "x86_64-unknown-linux-android${AndroidAPILevel}" }
              'armv7' { "armv7-unknown-linux-androideabi${AndroidAPILevel}" }
              'arm64' { "aarch64-unknown-linux-android${AndroidAPILevel}" }
              default { throw "Unsupported Android architecture: $Arch" }
            }
          }
          'Darwin' { "${Arch}-apple-macosx15.0" }
          default { throw "Unsupported OS: $OS" }
        }

        $UseASM = $UseBuiltCompilers.Contains("ASM") -or $UsePinnedCompilers.Contains("ASM")
        $UseASM_MASM = $UseMSVCCompilers.Contains("ASM_MASM")
        $UseC = $UseBuiltCompilers.Contains("C") -or $UseMSVCCompilers.Contains("C") -or $UsePinnedCompilers.Contains("C")
        $UseCXX = $UseBuiltCompilers.Contains("CXX") -or $UseMSVCCompilers.Contains("CXX") -or $UsePinnedCompilers.Contains("CXX")
        $UseSwift = $UseBuiltCompilers.Contains("Swift") -or $UsePinnedCompilers.Contains("Swift")

        # Add additional defines (unless already present)
        $Defines = $CMakeDefines.Clone()

        Add-KeyValueIfNew $Defines CMAKE_BUILD_TYPE Release

        # Avoid specifying `CMAKE_SYSTEM_NAME` and `CMAKE_SYSTEM_PROCESSOR` on
        # Windows and in the case that we are not cross-compiling.
        # DISCREPANCY: Build-CMakeProject uses a different condition:
        # (($Platform.OS -ne [OS]::Windows) -or ($Platform.Architecture.CMakeName -ne $BuildPlatform.Architecture.CMakeName))
        # which specifically excludes Windows native builds rather than checking for any cross-compile scenario.
        if ($OS -ne $BuildOS -or $Arch -ne $BuildArch) {
          Add-KeyValueIfNew $Defines CMAKE_SYSTEM_NAME $OS
          Add-KeyValueIfNew $Defines CMAKE_SYSTEM_PROCESSOR $CMakeArch
        }

        # Always prefer the CONFIG format for the packages so that we can build
        # against the build tree.
        Add-KeyValueIfNew $Defines CMAKE_FIND_PACKAGE_PREFER_CONFIG YES

        switch ($OS) {
          'Windows' {
            if ($UseASM) {
              $Driver = $(if ($UseGNUDriver) { "clang.exe" } else { "clang-cl.exe" })
              $ASM = if ($UseBuiltCompilers.Contains("ASM")) {
                "${env:GITHUB_WORKSPACE}/BinaryCache/Library/Developer/Toolchains/${SwiftVersion}+Asserts/usr/bin/${Driver}"
              } elseif ($UsePinnedCompilers.Contains("ASM")) {
                # The pinned toolchain is already in the path.
                $Driver
              }

              Add-KeyValueIfNew $Defines CMAKE_ASM_COMPILER $ASM
              Add-KeyValueIfNew $Defines CMAKE_ASM_FLAGS @("--target=$Triple")
              Add-KeyValueIfNew $Defines CMAKE_ASM_COMPILE_OPTIONS_MSVC_RUNTIME_LIBRARY_MultiThreadedDLL "/MD"

              if ($DebugInfo) {
                # DISCREPANCY: Build-CMakeProject supports both DWARF and codeview debug formats
                # via $CDebugFormat; this action only supports codeview.
                $ASMDebugFlags = if ($UseGNUDriver) { @("-gcodeview") } else { @("-clang:-gcodeview") }

                # CMake does not set a default value for the ASM compiler debug
                # information format flags with non-MSVC compilers, so we explicitly
                # set a default here.
                Add-FlagsDefine $Defines CMAKE_ASM_COMPILE_OPTIONS_MSVC_DEBUG_INFORMATION_FORMAT_Embedded $ASMDebugFlags
              }
            }

            if ($UseASM_MASM) {
              $ASM_MASM = if (${Arch} -eq "x86") {
                "ml.exe"
              } else {
                "ml64.exe"
              }

              Add-KeyValueIfNew $Defines CMAKE_ASM_MASM_COMPILER $ASM_MASM
              Add-KeyValueIfNew $Defines CMAKE_ASM_MASM_FLAGS @("/nologo" , "/quiet")
            }

            if ($UseC) {
              $CC = if ($UseMSVCCompilers.Contains("C")) {
                "cl.exe"
              } else {
                $Driver = $(if ($UseGNUDriver) { "clang.exe" } else { "clang-cl.exe" })
                if ($UseBuiltCompilers.Contains("C")) {
                  "${env:GITHUB_WORKSPACE}/BinaryCache/Library/Developer/Toolchains/${SwiftVersion}+Asserts/usr/bin/${Driver}"
                } elseif ($UsePinnedCompilers.Contains("C")) {
                  # The pinned toolchain is already in the path.
                  $Driver
                }
              }

              Add-KeyValueIfNew $Defines CMAKE_C_COMPILER $CC
              Add-KeyValueIfNew $Defines CMAKE_C_COMPILER_TARGET $Triple

              $CFLAGS = if ($UseGNUDriver) {
                # TODO(compnerd) we should consider enabling stack protector usage for standard libraries.
                @("-fno-stack-protector", "-ffunction-sections", "-fdata-sections", "-fomit-frame-pointer")
              } elseif ($UseMSVCCompilers.Contains("C")) {
                @("/GS-", "/Gw", "/Gy", "/Oy", "/Oi", "/Zc:preprocessor", "/Zc:inline")
              } else {
                # clang-cl does not support the /Zc:preprocessor flag.
                @("/GS-", "/Gw", "/Gy", "/Oy", "/Oi", "/Zc:inline")
              }

              # DISCREPANCY: Build-CMakeProject adds CAS flags here when $EnableCAS is true:
              # @("-fdepscan=inline", "-fdepscan-include-tree", "-Xclang", "-fcas-path", "-Xclang", $CASPath)
              # DISCREPANCY: Build-CMakeProject adds DWARF debug flags here when $CDebugFormat -eq "dwarf":
              # @("-gdwarf") or @("-clang:-gdwarf")

              Add-FlagsDefine $Defines CMAKE_C_FLAGS $CFLAGS
            }

            if ($UseCXX) {
              $CXX = if ($UseMSVCCompilers.Contains("CXX")) {
                "cl.exe"
              } else {
                $Driver = $(if ($UseGNUDriver) { "clang++.exe" } else { "clang-cl.exe" })
                if ($UseBuiltCompilers.Contains("CXX")) {
                  "${env:GITHUB_WORKSPACE}/BinaryCache/Library/Developer/Toolchains/${SwiftVersion}+Asserts/usr/bin/${Driver}"
                } elseif ($UsePinnedCompilers.Contains("CXX")) {
                  # The pinned toolchain is already in the path.
                  $Driver
                }
              }

              Add-KeyValueIfNew $Defines CMAKE_CXX_COMPILER $CXX
              Add-KeyValueIfNew $Defines CMAKE_CXX_COMPILER_TARGET $Triple

              $CXXFLAGS = if ($UseGNUDriver) {
                # TODO(compnerd) we should consider enabling stack protector usage for standard libraries.
                @("-fno-stack-protector", "-ffunction-sections", "-fdata-sections", "-fomit-frame-pointer")
              } elseif ($UseMSVCCompilers.Contains("CXX")) {
                @("/GS-", "/Gw", "/Gy", "/Oy", "/Oi", "/Zc:preprocessor", "/Zc:inline", "/Zc:__cplusplus")
              } else {
                # clang-cl does not support the /Zc:preprocessor flag.
                @("/GS-", "/Gw", "/Gy", "/Oy", "/Oi", "/Zc:inline", "/Zc:__cplusplus")
              }

              # DISCREPANCY: Build-CMakeProject adds CAS flags here when $EnableCAS is true:
              # @("-fdepscan=inline", "-fdepscan-include-tree", "-Xclang", "-fcas-path", "-Xclang", $CASPath)
              # DISCREPANCY: Build-CMakeProject adds DWARF debug flags here when $CDebugFormat -eq "dwarf":
              # @("-gdwarf") or @("-clang:-gdwarf")

              Add-FlagsDefine $Defines CMAKE_CXX_FLAGS $CXXFLAGS
            }

            if ($UseSwift) {
              if ($UseBuiltCompilers.Contains("Swift")) {
                Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER_WORKS "YES"
              }

              $SWIFTC = if ($UseBuiltCompilers.Contains("Swift")) {
                "${env:GITHUB_WORKSPACE}/BinaryCache/Library/Developer/Toolchains/${SwiftVersion}+Asserts/usr/bin/swiftc.exe"
              } elseif ($UsePinnedCompilers.Contains("Swift")) {
                "swiftc.exe"
              }

              Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER $SWIFTC
              Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER_TARGET $Triple

              # TODO(compnerd): remove this once we have the early swift-driver
              # DISCREPANCY: Build-CMakeProject does NOT set CMAKE_Swift_COMPILER_USE_OLD_DRIVER
              Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER_USE_OLD_DRIVER "YES"

              [string[]] $SwiftFlags = if ($SwiftSDK) {
                @("-sdk", $SwiftSDK)
              } else {
                @()
              }

              # DISCREPANCY: Build-CMakeProject supports DWARF debug format via $SwiftDebugFormat:
              # @("-g", "-debug-info-format=dwarf", "-use-ld=lld-link", "-Xlinker", "/DEBUG:DWARF")
              # This action only supports codeview.
              $SwiftFlags += if ($DebugInfo) {
                @("-g", "-debug-info-format=codeview", "-Xlinker", "/DEBUG")
              } else {
                @("-gnone")
              }

              # Disable EnC as that introduces padding in the conformance tables
              $SwiftFlags += @("-Xlinker", "/INCREMENTAL:NO")
              # Swift requires COMDAT folding and de-duplication
              $SwiftFlags += @("-Xlinker", "/OPT:REF", "-Xlinker", "/OPT:ICF")

              Add-FlagsDefine $Defines CMAKE_Swift_FLAGS $SwiftFlags
              # Workaround CMake 3.26+ enabling `-wmo` by default on release builds
              Add-FlagsDefine $Defines CMAKE_Swift_FLAGS_RELEASE "-O"
              Add-FlagsDefine $Defines CMAKE_Swift_FLAGS_RELWITHDEBINFO "-O"
            }

            $LinkerFlags = if ($UseGNUDriver) {
              @("-Xlinker", "/INCREMENTAL:NO", "-Xlinker", "/OPT:REF", "-Xlinker", "/OPT:ICF")
            } else {
              @("/INCREMENTAL:NO", "/OPT:REF", "/OPT:ICF")
            }

            if ($DebugInfo) {
              if ($UseASM -or $UseC -or $UseCXX) {
                # Prefer `/Z7` over `/ZI`
                # By setting the debug information format, the appropriate C/C++
                # flags will be set for codeview debug information format so there
                # is no need to set them explicitly above.
                Add-KeyValueIfNew $Defines CMAKE_MSVC_DEBUG_INFORMATION_FORMAT Embedded
                Add-KeyValueIfNew $Defines CMAKE_POLICY_DEFAULT_CMP0141 NEW

                $LinkerFlags += if ($UseGNUDriver) {
                  @("-Xlinker", "/DEBUG")
                } else {
                  @("/DEBUG")
                }

              }
            }

            # DISCREPANCY: Build-CMakeProject adds /IGNORE:longsections linker flag when
            # $SwiftDebugFormat -eq "dwarf" and using lld-link; this action doesn't support DWARF.
            Add-FlagsDefine $Defines CMAKE_EXE_LINKER_FLAGS $LinkerFlags
            Add-FlagsDefine $Defines CMAKE_SHARED_LINKER_FLAGS $LinkerFlags
          }

          'Android' {
            $AndroidArchABI = switch ($Arch) {
              'i686' { "x86" }
              'x86_64' { "x86_64" }
              'armv7' { "armeabi-v7a" }
              'arm64' { "arm64-v8a" }
              default { throw "Unsupported architecture: $Arch" }
            }
            $AndroidArchLLVM = switch ($BuildArch) {
              'amd64' { "x86_64" }
              'arm64' { "aarch64" }
              default { throw "Unsupported architecture: $Arch" }
            }
            $AndroidNDKPath = $NDKPath
            $AndroidPrebuiltRoot = "$AndroidNDKPath\toolchains\llvm\prebuilt\$($BuildOS.ToLowerInvariant())-$($AndroidArchLLVM)"
            $AndroidSysroot = "$AndroidPrebuiltRoot\sysroot"

            Add-KeyValueIfNew $Defines CMAKE_ANDROID_API "$AndroidAPILevel"
            Add-KeyValueIfNew $Defines CMAKE_ANDROID_ARCH_ABI "$AndroidArchABI"
            Add-KeyValueIfNew $Defines CMAKE_ANDROID_NDK "$AndroidNDKPath"

            if ($UseASM) {
            }

            if ($UseC) {
              Add-KeyValueIfNew $Defines CMAKE_C_COMPILER_TARGET $Triple

              $CFLAGS = @("--sysroot=${AndroidSysroot}", "-ffunction-sections", "-fdata-sections")
              if ($DebugInfo) {
                # DISCREPANCY: Build-CMakeProject uses @("-gdwarf") without split;
                # this action uses @("-g", "-gsplit-dwarf").
                $CFLAGS += @("-g", "-gsplit-dwarf")
              }
              Add-FlagsDefine $Defines CMAKE_C_FLAGS $CFLAGS
            }

            if ($UseCXX) {
              Add-KeyValueIfNew $Defines CMAKE_CXX_COMPILER_TARGET $Triple

              $CXXFLAGS = @("--sysroot=${AndroidSysroot}", "-ffunction-sections", "-fdata-sections")
              if ($DebugInfo) {
                # DISCREPANCY: Build-CMakeProject uses @("-gdwarf") without split;
                # this action uses @("-g", "-gsplit-dwarf").
                $CXXFLAGS += @("-g", "-gsplit-dwarf")
              }
              Add-FlagsDefine $Defines CMAKE_CXX_FLAGS $CXXFLAGS
            }

            if ($UseSwift) {
              if ($UseBuiltCompilers.Contains("Swift")) {
                Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER_WORKS "YES"
              }

              # FIXME(compnerd) remove this once the old runtimes build path is removed.
              Add-KeyValueIfNew $Defines SWIFT_ANDROID_NDK_PATH "$AndroidNDKPath"

              $SWIFTC = if ($UseBuiltCompilers.Contains("Swift")) {
                "${Env:GITHUB_WORKSPACE}/BinaryCache/Library/Developer/Toolchains/${SwiftVersion}+Asserts/usr/bin/swiftc.exe"
              } else {
                # The pinned toolchain is already in the path.
                "swiftc.exe"
              }
              Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER $SWIFTC
              Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER_TARGET $Triple

              # TODO(compnerd) remove this once we have the early swift-driver
              # DISCREPANCY: Build-CMakeProject does NOT set CMAKE_Swift_COMPILER_USE_OLD_DRIVER
              Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER_USE_OLD_DRIVER "YES"

              $SwiftFlags = if ($SwiftSDK) {
                @("-sdk", $SwiftSDK, "-sysroot", $AndroidSysroot)
              } else {
                @()
              }

              $SwiftFlags += @(
                "-Xclang-linker", "-target", "-Xclang-linker", $Triple,
                "-Xclang-linker", "--sysroot", "-Xclang-linker", $AndroidSysroot,
                "-Xclang-linker", "-resource-dir", "-Xclang-linker", "${AndroidPrebuiltRoot}\lib\clang\${AndroidClangVersion}"
              )

              # DISCREPANCY: Build-CMakeProject adds an extra linker library path when $SwiftSDK is set:
              # @("-Xclang-linker", "-L", "-Xclang-linker", [IO.Path]::Combine($SwiftSDK, "usr", "lib", "swift", "android", $Platform.Architecture.LLVMName))

              $SwiftFlags += if ($DebugInfo) { @("-g") } else { @("-gnone") }

              Add-FlagsDefine $Defines CMAKE_Swift_FLAGS $SwiftFlags
              # Workaround CMake 3.26+ enabling `-wmo` by default on release builds
              Add-FlagsDefine $Defines CMAKE_Swift_FLAGS_RELEASE "-O"
              Add-FlagsDefine $Defines CMAKE_Swift_FLAGS_RELWITHDEBINFO "-O"
            }

            $UseBuiltASMCompiler = $UseBuiltCompilers.Contains("ASM")
            $UseBuiltCCompiler = $UseBuiltCompilers.Contains("C")
            $UseBuiltCXXCompiler = $UseBuiltCompilers.Contains("CXX")

            if ($UseBuiltASMCompiler -or $UseBuiltCCompiler -or $UseBuiltCXXCompiler) {
              # Use a built lld linker as the Android's NDK linker might be too old
              # and not support all required relocations needed by the Swift
              # runtime.
              $ld = "${Env:GITHUB_WORKSPACE}/BinaryCache/Library/Developer/Toolchains/${SwiftVersion}+Asserts/usr/bin/ld.lld"
              Add-FlagsDefine $Defines CMAKE_SHARED_LINKER_FLAGS "--ld-path=$ld"
              Add-FlagsDefine $Defines CMAKE_EXE_LINKER_FLAGS "--ld-path=$ld"
            }

            # TODO(compnerd) we should understand why CMake does not understand
            # that the object file format is ELF when targeting Android on Windows.
            # This indication allows it to understand that it can use `chrpath` to
            # change the RPATH on the dynamic libraries.
            Add-FlagsDefine $Defines CMAKE_EXECUTABLE_FORMAT "ELF"
          }
        }

        # TODO(steelskin): sccache does not work with "-gsplit-dwarf".
        # DISCREPANCY: Build-CMakeProject does not have the Android exclusion check;
        # it enables caching regardless of OS. This action excludes Android due to -gsplit-dwarf.
        if ($EnableCaching -and $OS -ne "Android") {
          if ($UseC) {
            Add-KeyValueIfNew $Defines CMAKE_C_COMPILER_LAUNCHER "sccache"
          }

          if ($UseCXX) {
            Add-KeyValueIfNew $Defines CMAKE_CXX_COMPILER_LAUNCHER "sccache"
          }
        }

        if ($InstallDir) {
          Add-KeyValueIfNew $Defines CMAKE_INSTALL_PREFIX $InstallDir
        }

        # DISCREPANCY: Build-CMakeProject sets CMAKE_MAKE_PROGRAM to $ninja; this action does not.
        # DISCREPANCY: Build-CMakeProject has a $Generator parameter (defaults to "Ninja");
        # this action hardcodes "Ninja".

        # Generate the project
        $cmakeGenerateArgs = @("-B", $BinDir, "-S", $SrcDir, "-G", "Ninja")
        if ($CacheScript) {
          $cmakeGenerateArgs += @("-C", $CacheScript)
        }

        foreach ($Define in ($Defines.GetEnumerator() | Sort-Object Name)) {
          # The quoting gets tricky to support defines containing compiler flags args,
          # some of which can contain spaces, for example `-D` `Flags=-flag "C:/Program Files"`
          # Avoid backslashes since they are going into CMakeCache.txt,
          # where they are interpreted as escapes.
          if ($Define.Value -is [string]) {
            # Single token value, no need to quote spaces, the splat operator does the right thing.
            $Value = $Define.Value.Replace("\", "/")
          } else {
            # Flags array, multiple tokens, quoting needed for tokens containing spaces
            $Value = ""
            foreach ($Arg in $Define.Value) {
              if ($Value.Length -gt 0) {
                $Value += " "
              }

              $ArgWithForwardSlashes = $Arg.Replace("\", "/")
              if ($ArgWithForwardSlashes.Contains(" ")) {
                # Escape the quote so it makes it through. PowerShell 5 and Core
                # handle quotes differently, so we need to check the version.
                $quote = if ($PSEdition  -eq "Core") { '"' } else { '\"' }
                $Value += "$quote$ArgWithForwardSlashes$quote"
              } else {
                $Value += $ArgWithForwardSlashes
              }
            }
          }

          $cmakeGenerateArgs += @("-D", "$($Define.Key)=$Value")
        }

        Write-Host "ℹ️ Configuring project ${ProjectName}:"
        Write-Host 'cmake `'
        for ($i = 0; $i -lt $cmakeGenerateArgs.Length; $i += 1) {
          $Arg = $cmakeGenerateArgs[$i]
          if ($Arg -match '\s') {
            Write-Host "  `'$Arg`'" -NoNewline
          } else {
            Write-Host "  $Arg" -NoNewline
          }

          if ((-not ($Arg -match '^-')) -and ($i -lt ($cmakeGenerateArgs.Length - 1))) {
            # Write a newline for non-option arguments.
            Write-Host " ``"
          }
        }
        Write-Host "`n"

        # DISCREPANCY: Build-CMakeProject sets up $env:Path with Swift runtime directories
        # before invoking cmake when using built or pinned Swift compilers. This action does not.
        # DISCREPANCY: Build-CMakeProject builds the project after configuration (via $BuildTargets
        # parameter or implicit install target). This action only configures.
        & cmake @cmakeGenerateArgs
        if ($LASTEXITCODE -ne 0) {
          throw "CMake generation failed for project ${ProjectName} with exit code $LASTEXITCODE."
        }
