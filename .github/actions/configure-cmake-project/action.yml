name: Configure CMake Project
description: Configure a CMake project using the specified build type and configuration.

inputs:
  project-name:
    description: Name of the CMake project to build.
    required: true
  swift-version:
    description: Built Swift compiler version.
    required: true
  enable-caching:
    description: Enable sccache.
    required: false
    default: false
  debug-info:
    description: Enable debug information in the build.
    required: false
    default: false
  build-os:
    description: Build operating system (e.g., "Windows", "Darwin").
    required: true
  build-arch:
    description: Build architecture (e.g., "x86_64", "arm64").
    required: true
  os:
    description: Operating system to build for (e.g., "Windows", "Android").
    required: true
  arch:
    description: Architecture to build for (e.g., "amd64", "arm64").
    required: true
  src-dir:
    description: Path to the source directory of the CMake project.
    required: true
  bin-dir:
    description: Path to the output directory for the build artifacts.
    required: true
  install-dir:
    description: Path to the installation directory for the built artifacts.
    required: false
    default: ''
  android-api-level:
    description: Android API level to target.
    required: false
    default: ''
  android-clang-version:
    description: Version of the Android Clang toolchain to use.
    required: false
    default: ''
  ndk-path:
    description: Path to the Android NDK.
    required: false
    default: ''
  swift-sdk-path:
    description: Path to the Swift SDK.
    required: false
    default: ''
  msvc-compilers:
    description: List of languages to build with the MSVC compilers (e.g. "C", "CXX", "ASM_MASM").
    required: false
    default: '@()'
  built-compilers:
    description: |
      List of languages to build with the built compilers (e.g. "C", "CXX", "ASM", "Swift").
    required: false
    default: '@()'
  pinned-compilers:
    description: |
      List of languages to build with the pinned compilers (e.g. "C", "CXX", "ASM", "Swift").
    required: false
    default: '@()'
  use-gnu-driver:
    description: Use the GNU driver for building the project.
    required: false
    default: false
  cache-script:
    description: Optional path to a CMake Cache file.
    required: false
    default: ''
  cmake-defines:
    description: |
      Additional CMake definitions to pass to the build system (e.g. "CMAKE_BUILD_TYPE=Release").
    required: false
    default: '@{}'

runs:
  using: 'composite'
  steps:
    - name: Configure ${{ inputs.project-name }}
      shell: pwsh
      run: |
        Remove-Item env:\SDKROOT -ErrorAction SilentlyContinue
        $ExeSuffix = if ($IsWindows) { ".exe" } else { "" }

        $ProjectName = '${{ inputs.project-name }}'
        $SwiftVersion = '${{ inputs.swift-version }}'
        $EnableCaching = ${{ inputs.enable-caching == 'true' && '$True' || '$False' }}
        $DebugInfo = ${{ inputs.debug-info == 'true' && '$True' || '$False' }}
        $BuildOS = '${{ inputs.build-os }}'
        $BuildArch = '${{ inputs.build-arch }}'
        $OS = '${{ inputs.os }}'
        $Arch = '${{ inputs.arch }}'
        $SrcDir = '${{ inputs.src-dir }}'
        $BinDir = '${{ inputs.bin-dir }}'
        $InstallDir = '${{ inputs.install-dir }}'
        $AndroidAPILevel = '${{ inputs.android-api-level }}'
        $AndroidClangVersion = '${{ inputs.android-clang-version }}'
        $NDKPath = '${{ inputs.ndk-path }}'
        $SwiftSDK = '${{ inputs.swift-sdk-path }}'
        $UseMSVCCompilers = ${{ inputs.msvc-compilers }}
        $UseBuiltCompilers = ${{ inputs.built-compilers }}
        $UsePinnedCompilers = ${{ inputs.pinned-compilers }}
        $UseGNUDriver = ${{ inputs.use-gnu-driver == 'true' && '&True' || '$False' }}
        $CacheScript = '${{ inputs.cache-script }}'
        $CMakeDefines = ${{ inputs.cmake-defines }}

        function Add-KeyValueIfNew([hashtable]$Hashtable, [string]$Key, [string]$Value) {
          if (-not $Hashtable.Contains($Key)) {
            $Hashtable.Add($Key, $Value)
          }
        }

        function Add-FlagsDefine([hashtable]$Defines, [string]$Name, [string[]]$Value) {
          if ($Defines.Contains($Name)) {
            $Defines[$name] = @($Defines[$name]) + $Value
          } else {
            $Defines.Add($Name, $Value)
          }
        }

        $CMakeArch = switch ($OS) {
          'Windows' { $Arch.ToUpperInvariant() }
          'Android' {
            switch ($Arch) {
              'arm64' { 'aarch64' }
              'x86_64' { 'x86_64' }
              'i686' { 'i686' }
              'armv7' { 'armv7-a' }
              default { throw "Unsupported Android architecture: $Arch" }
            } 
          }
          "Darwin" { $Arch }
          default { throw "Unsupported OS: $OS" }
        }

        $Triple = switch ($OS) {
          'Windows' {
            switch ($Arch) {
              'x86' { "i686-unknown-windows-msvc" }
              'amd64' { "x86_64-unknown-windows-msvc" }
              'arm64' { "aarch64-unknown-windows-msvc" }
              default { throw "Unsupported Windows architecture: $Arch" }
            }
          }
          'Android' {
            switch ($Arch) {
              'i686' { "i686-unknown-linux-android${AndroidAPILevel}" }
              'x86_64' { "x86_64-unknown-linux-android${AndroidAPILevel}" }
              'armv7' { "armv7-unknown-linux-androideabi${AndroidAPILevel}" }
              'arm64' { "aarch64-unknown-linux-android${AndroidAPILevel}" }
              default { throw "Unsupported Android architecture: $Arch" }
            }
          }
          'Darwin' { "${Arch}-apple-macosx15.0" }
          default { throw "Unsupported OS: $OS" }
        }

        $UseASM = $UseBuiltCompilers.Contains("ASM") -or $UsePinnedCompilers.Contains("ASM")
        $UseASM_MASM = $UseMSVCCompilers.Contains("ASM_MASM")
        $UseC = $UseBuiltCompilers.Contains("C") -or $UseMSVCCompilers.Contains("C") -or $UsePinnedCompilers.Contains("C")
        $UseCXX = $UseBuiltCompilers.Contains("CXX") -or $UseMSVCCompilers.Contains("CXX") -or $UsePinnedCompilers.Contains("CXX")
        $UseSwift = $UseBuiltCompilers.Contains("Swift") -or $UsePinnedCompilers.Contains("Swift")

        # Add additional defines (unless already present)
        $Defines = $CMakeDefines.Clone()

        Add-KeyValueIfNew $Defines CMAKE_BUILD_TYPE Release

        # Avoid specifying `CMAKE_SYSTEM_NAME` and `CMAKE_SYSTEM_PROCESSOR` on
        # Windows and in the case that we are not cross-compiling.
        if ($OS -ne $BuildOS -or $Arch -ne $BuildArch) {
          Add-KeyValueIfNew $Defines CMAKE_SYSTEM_NAME $OS
          Add-KeyValueIfNew $Defines CMAKE_SYSTEM_PROCESSOR $CMakeArch
        }

        # Always prefer the CONFIG format for the packages so that we can build
        # against the build tree.
        Add-KeyValueIfNew $Defines CMAKE_FIND_PACKAGE_PREFER_CONFIG YES

        switch ($OS) {
          'Windows' {
            if ($UseASM) {
              $Driver = $(if ($UseGNUDriver) { "clang.exe" } else { "clang-cl.exe" })
              $ASM = if ($UseBuiltCompilers.Contains("ASM")) {
                "${env:GITHUB_WORKSPACE}/BinaryCache/Library/Developer/Toolchains/${SwiftVersion}+Asserts/usr/bin/${Driver}"
              } elseif ($UsePinnedCompilers.Contains("ASM")) {
                # The pinned toolchain is already in the path.
                $Driver
              }

              Add-KeyValueIfNew $Defines CMAKE_ASM_COMPILER $ASM
              Add-KeyValueIfNew $Defines CMAKE_ASM_FLAGS @("--target=$Triple")
              Add-KeyValueIfNew $Defines CMAKE_ASM_COMPILE_OPTIONS_MSVC_RUNTIME_LIBRARY_MultiThreadedDLL "/MD"

              if ($DebugInfo) {
                $ASMDebugFlags = if ($UseGNUDriver) { @("-gcodeview") } else { @("-clang:-gcodeview") }

                # CMake does not set a default value for the ASM compiler debug
                # information format flags with non-MSVC compilers, so we explicitly
                # set a default here.
                Add-FlagsDefine $Defines CMAKE_ASM_COMPILE_OPTIONS_MSVC_DEBUG_INFORMATION_FORMAT_Embedded $ASMDebugFlags
              }
            }

            if ($UseASM_MASM) {
              $ASM_MASM = if (${Arch} -eq "x86") {
                "ml.exe"
              } else {
                "ml64.exe"
              }

              Add-KeyValueIfNew $Defines CMAKE_ASM_MASM_COMPILER $ASM_MASM
              Add-KeyValueIfNew $Defines CMAKE_ASM_MASM_FLAGS @("/nologo" , "/quiet")
            }

            if ($UseC) {
              $CC = if ($UseMSVCCompilers.Contains("C")) {
                "cl.exe"
              } else {
                $Driver = $(if ($UseGNUDriver) { "clang.exe" } else { "clang-cl.exe" })
                if ($UseBuiltCompilers.Contains("C")) {
                  "${env:GITHUB_WORKSPACE}/BinaryCache/Library/Developer/Toolchains/${SwiftVersion}+Asserts/usr/bin/${Driver}"
                } elseif ($UsePinnedCompilers.Contains("C")) {
                  # The pinned toolchain is already in the path.
                  $Driver
                }
              }

              Add-KeyValueIfNew $Defines CMAKE_C_COMPILER $CC
              Add-KeyValueIfNew $Defines CMAKE_C_COMPILER_TARGET $Triple

              $CFLAGS = if ($UseGNUDriver) {
                # TODO(compnerd) we should consider enabling stack protector usage for standard libraries.
                @("-fno-stack-protector", "-ffunction-sections", "-fdata-sections", "-fomit-frame-pointer")
              } elseif ($UseMSVCCompilers.Contains("C")) {
                @("/GS-", "/Gw", "/Gy", "/Oy", "/Oi", "/Zc:preprocessor", "/Zc:inline")
              } else {
                # clang-cl does not support the /Zc:preprocessor flag.
                @("/GS-", "/Gw", "/Gy", "/Oy", "/Oi", "/Zc:inline")
              }

              Add-FlagsDefine $Defines CMAKE_C_FLAGS $CFLAGS
            }

            if ($UseCXX) {
              $CXX = if ($UseMSVCCompilers.Contains("CXX")) {
                "cl.exe"
              } else {
                $Driver = $(if ($UseGNUDriver) { "clang++.exe" } else { "clang-cl.exe" })
                if ($UseBuiltCompilers.Contains("CXX")) {
                  "${env:GITHUB_WORKSPACE}/BinaryCache/Library/Developer/Toolchains/${SwiftVersion}+Asserts/usr/bin/${Driver}"
                } elseif ($UsePinnedCompilers.Contains("CXX")) {
                  # The pinned toolchain is already in the path.
                  $Driver
                }
              }

              Add-KeyValueIfNew $Defines CMAKE_CXX_COMPILER $CXX
              Add-KeyValueIfNew $Defines CMAKE_CXX_COMPILER_TARGET $Triple

              $CXXFLAGS = if ($UseGNUDriver) {
                # TODO(compnerd) we should consider enabling stack protector usage for standard libraries.
                @("-fno-stack-protector", "-ffunction-sections", "-fdata-sections", "-fomit-frame-pointer")
              } elseif ($UseMSVCCompilers.Contains("CXX")) {
                @("/GS-", "/Gw", "/Gy", "/Oy", "/Oi", "/Zc:preprocessor", "/Zc:inline", "/Zc:__cplusplus")
              } else {
                # clang-cl does not support the /Zc:preprocessor flag.
                @("/GS-", "/Gw", "/Gy", "/Oy", "/Oi", "/Zc:inline", "/Zc:__cplusplus")
              }

              Add-FlagsDefine $Defines CMAKE_CXX_FLAGS $CXXFLAGS
            }

            if ($UseSwift) {
              if ($UseBuiltCompilers.Contains("Swift")) {
                Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER_WORKS "YES"
              }

              $SWIFTC = if ($UseBuiltCompilers.Contains("Swift")) {
                "${env:GITHUB_WORKSPACE}/BinaryCache/Library/Developer/Toolchains/${SwiftVersion}+Asserts/usr/bin/swiftc.exe"
              } elseif ($UsePinnedCompilers.Contains("Swift")) {
                "swiftc.exe"
              }

              Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER $SWIFTC

              $TargetInfo = & $SWIFTC -target $Triple -print-target-info
              $TargetInfo = $TargetInfo | ConvertFrom-Json
              $TargetInfo = $TargetInfo.target.moduleTriple
              Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER_TARGET $TargetInfo

              # TODO(compnerd): remove this once we have the early swift-driver
              Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER_USE_OLD_DRIVER "YES"

              [string[]] $SwiftFlags = if ($SwiftSDK) {
                @("-sdk", $SwiftSDK)
              } else {
                @()
              }

              $SwiftFlags += if ($DebugInfo) {
                @("-g", "-debug-info-format=codeview", "-Xlinker", "/DEBUG")
              } else {
                @("-gnone")
              }

              # Disable EnC as that introduces padding in the conformance tables
              $SwiftFlags += @("-Xlinker", "/INCREMENTAL:NO")
              # Swift requires COMDAT folding and de-duplication
              $SwiftFlags += @("-Xlinker", "/OPT:REF", "-Xlinker", "/OPT:ICF")

              Add-FlagsDefine $Defines CMAKE_Swift_FLAGS $SwiftFlags
              # Workaround CMake 3.26+ enabling `-wmo` by default on release builds
              Add-FlagsDefine $Defines CMAKE_Swift_FLAGS_RELEASE "-O"
              Add-FlagsDefine $Defines CMAKE_Swift_FLAGS_RELWITHDEBINFO "-O"
            }

            $LinkerFlags = if ($UseGNUDriver) {
              @("-Xlinker", "/INCREMENTAL:NO", "-Xlinker", "/OPT:REF", "-Xlinker", "/OPT:ICF")
            } else {
              @("/INCREMENTAL:NO", "/OPT:REF", "/OPT:ICF")
            }

            if ($DebugInfo) {
              if ($UseASM -or $UseC -or $UseCXX) {
                # Prefer `/Z7` over `/ZI`
                # By setting the debug information format, the appropriate C/C++
                # flags will be set for codeview debug information format so there
                # is no need to set them explicitly above.
                Add-KeyValueIfNew $Defines CMAKE_MSVC_DEBUG_INFORMATION_FORMAT Embedded
                Add-KeyValueIfNew $Defines CMAKE_POLICY_DEFAULT_CMP0141 NEW

                $LinkerFlags += if ($UseGNUDriver) {
                  @("-Xlinker", "/DEBUG")
                } else {
                  @("/DEBUG")
                }

              }
            }

            Add-FlagsDefine $Defines CMAKE_EXE_LINKER_FLAGS $LinkerFlags
            Add-FlagsDefine $Defines CMAKE_SHARED_LINKER_FLAGS $LinkerFlags
          }

          'Android' {
            $AndroidArchABI = switch ($Arch) {
              'i686' { "x86" }
              'x86_64' { "x86_64" }
              'armv7' { "armeabi-v7a" }
              'arm64' { "arm64-v8a" }
              default { throw "Unsupported architecture: $Arch" }
            }
            $AndroidArchLLVM = switch ($BuildArch) {
              'amd64' { "x86_64" }
              'arm64' { "aarch64" }
              default { throw "Unsupported architecture: $Arch" }
            }
            $AndroidNDKPath = $NDKPath
            $AndroidPrebuiltRoot = "$AndroidNDKPath\toolchains\llvm\prebuilt\$($BuildOS.ToLowerInvariant())-$($AndroidArchLLVM)"
            $AndroidSysroot = "$AndroidPrebuiltRoot\sysroot"

            Add-KeyValueIfNew $Defines CMAKE_ANDROID_API "$AndroidAPILevel"
            Add-KeyValueIfNew $Defines CMAKE_ANDROID_ARCH_ABI "$AndroidArchABI"
            Add-KeyValueIfNew $Defines CMAKE_ANDROID_NDK "$AndroidNDKPath"

            if ($UseASM) {
            }

            if ($UseC) {
              Add-KeyValueIfNew $Defines CMAKE_C_COMPILER_TARGET $Triple

              $CFLAGS = @("--sysroot=${AndroidSysroot}", "-ffunction-sections", "-fdata-sections")
              if ($DebugInfo) {
                $CFLAGS += @("-g", "-gsplit-dwarf")
              }
              Add-FlagsDefine $Defines CMAKE_C_FLAGS $CFLAGS
            }

            if ($UseCXX) {
              Add-KeyValueIfNew $Defines CMAKE_CXX_COMPILER_TARGET $Triple

              $CXXFLAGS = @("--sysroot=${AndroidSysroot}", "-ffunction-sections", "-fdata-sections")
              if ($DebugInfo) {
                $CXXFLAGS += @("-g", "-gsplit-dwarf")
              }
              Add-FlagsDefine $Defines CMAKE_CXX_FLAGS $CXXFLAGS
            }

            if ($UseSwift) {
              if ($UseBuiltCompilers.Contains("Swift")) {
                Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER_WORKS "YES"
              }

              # FIXME(compnerd) remove this once the old runtimes build path is removed.
              Add-KeyValueIfNew $Defines SWIFT_ANDROID_NDK_PATH "$AndroidNDKPath"

              $SWIFTC = if ($UseBuiltCompilers.Contains("Swift")) {
                "${Env:GITHUB_WORKSPACE}/BinaryCache/Library/Developer/Toolchains/${SwiftVersion}+Asserts/usr/bin/swiftc.exe"
              } else {
                # The pinned toolchain is already in the path.
                "swiftc.exe"
              }
              Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER $SWIFTC

              $TargetInfo = & $SWIFTC -target $Triple -print-target-info
              $TargetInfo = $TargetInfo | ConvertFrom-Json
              $TargetInfo = $TargetInfo.target.moduleTriple
              Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER_TARGET $TargetInfo

              # TODO(compnerd) remove this once we have the early swift-driver
              Add-KeyValueIfNew $Defines CMAKE_Swift_COMPILER_USE_OLD_DRIVER "YES"

              $SwiftFlags = if ($SwiftSDK) {
                @("-sdk", $SwiftSDK, "-sysroot", $AndroidSysroot)
              } else {
                @()
              }

              $SwiftFlags += @(
                "-Xclang-linker", "-target", "-Xclang-linker", $Triple,
                "-Xclang-linker", "--sysroot", "-Xclang-linker", $AndroidSysroot,
                "-Xclang-linker", "-resource-dir", "-Xclang-linker", "${AndroidPrebuiltRoot}\lib\clang\${AndroidClangVersion}"
              )

              $SwiftFlags += if ($DebugInfo) { @("-g") } else { @("-gnone") }

              Add-FlagsDefine $Defines CMAKE_Swift_FLAGS $SwiftFlags
              # Workaround CMake 3.26+ enabling `-wmo` by default on release builds
              Add-FlagsDefine $Defines CMAKE_Swift_FLAGS_RELEASE "-O"
              Add-FlagsDefine $Defines CMAKE_Swift_FLAGS_RELWITHDEBINFO "-O"
            }

            $UseBuiltASMCompiler = $UseBuiltCompilers.Contains("ASM")
            $UseBuiltCCompiler = $UseBuiltCompilers.Contains("C")
            $UseBuiltCXXCompiler = $UseBuiltCompilers.Contains("CXX")

            if ($UseBuiltASMCompiler -or $UseBuiltCCompiler -or $UseBuiltCXXCompiler) {
              # Use a built lld linker as the Android's NDK linker might be too old
              # and not support all required relocations needed by the Swift
              # runtime.
              $ld = "${Env:GITHUB_WORKSPACE}/BinaryCache/Library/Developer/Toolchains/${SwiftVersion}+Asserts/usr/bin/ld.lld"
              Add-FlagsDefine $Defines CMAKE_SHARED_LINKER_FLAGS "--ld-path=$ld"
              Add-FlagsDefine $Defines CMAKE_EXE_LINKER_FLAGS "--ld-path=$ld"
            }

            # TODO(compnerd) we should understand why CMake does not understand
            # that the object file format is ELF when targeting Android on Windows.
            # This indication allows it to understand that it can use `chrpath` to
            # change the RPATH on the dynamic libraries.
            Add-FlagsDefine $Defines CMAKE_EXECUTABLE_FORMAT "ELF"
          }
        }

        # TODO(steelskin): sccache does not work with "-gsplit-dwarf".
        if ($EnableCaching -and $OS -ne "Android") {
          if ($UseC) {
            Add-KeyValueIfNew $Defines CMAKE_C_COMPILER_LAUNCHER "sccache"
          }

          if ($UseCXX) {
            Add-KeyValueIfNew $Defines CMAKE_CXX_COMPILER_LAUNCHER "sccache"
          }
        }

        if ($InstallDir) {
          Add-KeyValueIfNew $Defines CMAKE_INSTALL_PREFIX $InstallDir
        }

        # Generate the project
        $cmakeGenerateArgs = @("-B", $BinDir, "-S", $SrcDir, "-G", "Ninja")
        if ($CacheScript) {
          $cmakeGenerateArgs += @("-C", $CacheScript)
        }

        foreach ($Define in ($Defines.GetEnumerator() | Sort-Object Name)) {
          # The quoting gets tricky to support defines containing compiler flags args,
          # some of which can contain spaces, for example `-D` `Flags=-flag "C:/Program Files"`
          # Avoid backslashes since they are going into CMakeCache.txt,
          # where they are interpreted as escapes.
          if ($Define.Value -is [string]) {
            # Single token value, no need to quote spaces, the splat operator does the right thing.
            $Value = $Define.Value.Replace("\", "/")
          } else {
            # Flags array, multiple tokens, quoting needed for tokens containing spaces
            $Value = ""
            foreach ($Arg in $Define.Value) {
              if ($Value.Length -gt 0) {
                $Value += " "
              }

              $ArgWithForwardSlashes = $Arg.Replace("\", "/")
              if ($ArgWithForwardSlashes.Contains(" ")) {
                # Escape the quote so it makes it through. PowerShell 5 and Core
                # handle quotes differently, so we need to check the version.
                $quote = if ($PSEdition  -eq "Core") { '"' } else { '\"' }
                $Value += "$quote$ArgWithForwardSlashes$quote"
              } else {
                $Value += $ArgWithForwardSlashes
              }
            }
          }

          $cmakeGenerateArgs += @("-D", "$($Define.Key)=$Value")
        }

        Write-Host "ℹ️ Configuring project ${ProjectName}:"
        Write-Host 'cmake `'
        for ($i = 0; $i -lt $cmakeGenerateArgs.Length; $i += 1) {
          $Arg = $cmakeGenerateArgs[$i]
          if ($Arg -match '\s') {
            Write-Host "  `'$Arg`'" -NoNewline
          } else {
            Write-Host "  $Arg" -NoNewline
          }

          if ((-not ($Arg -match '^-')) -and ($i -lt ($cmakeGenerateArgs.Length - 1))) {
            # Write a newline for non-option arguments.
            Write-Host " ``"
          }
        }
        Write-Host "`n"

        & cmake @cmakeGenerateArgs
        if ($LASTEXITCODE -ne 0) {
          throw "CMake generation failed for project ${ProjectName} with exit code $LASTEXITCODE."
        }
